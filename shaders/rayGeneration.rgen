#version 460
#extension GL_EXT_ray_tracing : enable

// Ray generation shader

// State for Xorshift random number generator
struct RandomState
{
  uint x, y, z, w;
} randomState;

layout(binding = 0) uniform accelerationStructureEXT tlas;  // Acceleration structure (scene)
layout(binding = 1, rgba32f) uniform image2D targetImage; // Image to store rendering result
layout(binding = 2) uniform RayTracingUniform {
  mat4 invViewMat; // Inverse of view matrix (i.e. transform camera coordinate to world coordinate)
  mat4 invProjectionMat; // Inverse of projection matrix (i.e. transform normalized device coordinate into camera coordinate)
  uint samplesPerPixel; // How many rays are sampled to render one pixel
} uniforms;

layout(location = 0) rayPayloadEXT vec3 payload;

// Pseudo-random number using Xorshift (xor128)
// G. Marsaglia, "Xorshift RNGs", Journal of Statistical Software, vol. 8, no. 14, pp. 1-6, 2003, doi: 10.18637/jss.v008.i14
uint random()
{
  uint t = (randomState.x ^ (randomState.x << 11));
  randomState.x = randomState.y;
  randomState.y = randomState.z;
  randomState.z = randomState.w;
  return (randomState.w = (randomState.w ^ (randomState.w >> 19)) ^ (t ^ (t >> 8)));
}

// Initialize the RNG.
void initRandom(uint x)
{
  randomState.x = x;
  // Values of y, z, w are same as Marsaglia's paper.
  randomState.y = 362436069;
  randomState.z = 521288629;
  randomState.w = 88675123;
}

float randomFloat(float minimum, float maximum)
{
  return minimum + (float(random()) / 4294967296.0) * (maximum - minimum);
}

void main()
{
  // Initialize RNG using pixel coord as seed
  initRandom(gl_LaunchIDEXT.x ^ gl_LaunchIDEXT.y);

  vec3 meanColor = vec3(0.0);

  for (int i = 0; i < uniforms.samplesPerPixel; i++) {
    // Random jitter added to pixel coordinate for antialiasing
    vec2 jitter = vec2(randomFloat(0.0, 1.0), randomFloat(0.0, 1.0));
    // Pixel position in normalized device coordinate (-1 <= x,y <= 1)
    vec2 pixelNDC = 2.0 * (vec2(gl_LaunchIDEXT.xy) + jitter) / vec2(gl_LaunchSizeEXT.xy) - 1.0;
    // Ray direction in camera coordinate
    vec4 directionCam = uniforms.invProjectionMat * vec4(pixelNDC, 1.0, 1.0);
    // Ray direction in world coordinate
    vec3 direction = (uniforms.invViewMat * directionCam).xyz;
    // Ray origin (camera position) in world coordinate
    vec3 origin = (uniforms.invViewMat * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    float tMin = 0.00001;
    float tMax = 10000.0;

    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tMin, direction, tMax, 0);

    meanColor = (i * meanColor + payload) / (i + 1); 
  }

  imageStore(targetImage, ivec2(gl_LaunchIDEXT.xy), vec4(meanColor, 1.0));
}