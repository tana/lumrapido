#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_scalar_block_layout : enable

#include "common.glsl"

// Ray generation shader

// When using Quasi-Monte Carlo algorithm, many replications of scrambled Hammersley sequence using different permutations
// are generated and randomly selected one of them is used to render each pixel.
// See: T. Kollig and A. Keller, "Efficient Bidirectional Path Tracing by Randomized Quasi-Monte Carlo Integration," in Monte Carlo and Quasi-Monte Carlo Methods 2000, KT. Fang, H. Niederreiter, F.J. Hickernell, Eds. Springer, Berlin, Heidelberg. 2002. pp. 290-305.

const int MAX_DEPTH = 10;

const int SAMPLING_DIMENSIONS = 2 + 3 * MAX_DEPTH; // 2 for antialiasing, 3 per each depth of ray tracing
const int HAMMERSLEY_REPLICATIONS = 71; // This must agree with the definition in RayTracer.h

layout(binding = BINDING_TLAS) uniform accelerationStructureEXT tlas;  // Acceleration structure (scene)
layout(binding = BINDING_TARGET_IMAGE, rgba32f) writeonly uniform image2D targetImage; // Image to store rendering result
layout(binding = BINDING_UNIFORMS) uniform Uniforms {
  RayTracingUniform uniforms;
};

#ifdef ALGORITHM_QUASI_MONTE_CARLO
layout(binding = BINDING_HAMMERSLEY, scalar) readonly buffer HammersleySequence {
  float[] hammersley;
};
#endif

layout(location = 0) rayPayloadEXT RayPayload payload;

RandomState state;

#ifdef ALGORITHM_QUASI_MONTE_CARLO
uint replicationId;
#endif

// Get a [0,1) random or quasi-random number
float getRandom(int sampleId, int dim)
{
#if defined(ALGORITHM_PATH_TRACING)
  return randomFloat(state, 0.0, 1.0);
#elif defined(ALGORITHM_QUASI_MONTE_CARLO)
  return hammersley[(uniforms.samplesPerPixel * SAMPLING_DIMENSIONS) * replicationId + SAMPLING_DIMENSIONS * sampleId + dim];
#endif
}

void main()
{
  // Initialize RNG using pixel coord as seed
  initRandom(state, (gl_LaunchIDEXT.x << 16) | gl_LaunchIDEXT.y);

#ifdef ALGORITHM_QUASI_MONTE_CARLO
  // Randomly choose replication
  replicationId = random(state) % HAMMERSLEY_REPLICATIONS;
#endif

  vec3 meanColor = vec3(0.0);

  for (int sampleId = 0; sampleId < uniforms.samplesPerPixel; sampleId++) {
    // Random jitter added to pixel coordinate for antialiasing
    vec2 jitter = vec2(getRandom(sampleId, 0), getRandom(sampleId, 1));
    // Pixel position in normalized device coordinate (-1 <= x,y <= 1)
    vec2 pixelNDC = 2.0 * (vec2(gl_LaunchIDEXT.xy) + jitter) / vec2(gl_LaunchSizeEXT.xy) - 1.0;
    // Ray direction in camera coordinate
    vec4 directionCam = uniforms.invProjectionMat * vec4(pixelNDC, 1.0, 1.0);
    // Ray direction in world coordinate
    vec3 direction = (uniforms.invViewMat * directionCam).xyz;
    // Ray origin (camera position) in world coordinate
    vec3 origin = (uniforms.invViewMat * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    int depth = 0;
    payload.multiplier = vec3(1.0);
    payload.color = vec3(0.0);

    int dim = 2;

    do {
      // Generate random numbers used in the closest hit shader
      for (int i = 0; i < payload.random.length(); i++) {
        payload.random[i] = getRandom(sampleId, dim);
        dim++;
      }

      float tMin = 0.001;
      float tMax = 10000.0;

      traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tMin, direction, tMax, 0);

      origin = payload.nextOrigin;
      direction = payload.nextDirection;

      depth++;
    } while (payload.traceNextRay && depth < MAX_DEPTH);

    meanColor = (sampleId * meanColor + payload.color) / (sampleId + 1); 
  }

  // Gamma correction
  vec3 correctedColor = sqrt(meanColor);

  imageStore(targetImage, ivec2(gl_LaunchIDEXT.xy), vec4(correctedColor, 1.0));
}