#version 460
#extension GL_EXT_ray_tracing : enable

#include "common.glsl"

// Ray generation shader

const int MAX_DEPTH = 10;

layout(binding = 0) uniform accelerationStructureEXT tlas;  // Acceleration structure (scene)
layout(binding = 1, rgba32f) uniform image2D targetImage; // Image to store rendering result
layout(binding = 2) uniform Uniforms {
  RayTracingUniform uniforms;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
  // Initialize RNG using pixel coord as seed
  initRandom(payload.randomState, (gl_LaunchIDEXT.x << 16) | gl_LaunchIDEXT.y);

  vec3 meanColor = vec3(0.0);

  for (int i = 0; i < uniforms.samplesPerPixel; i++) {
#if 1
    // Random jitter added to pixel coordinate for antialiasing
    vec2 jitter = vec2(randomFloat(payload.randomState, 0.0, 1.0), randomFloat(payload.randomState, 0.0, 1.0));
    // Pixel position in normalized device coordinate (-1 <= x,y <= 1)
    vec2 pixelNDC = 2.0 * (vec2(gl_LaunchIDEXT.xy) + jitter) / vec2(gl_LaunchSizeEXT.xy) - 1.0;
    // Ray direction in camera coordinate
    vec4 directionCam = uniforms.invProjectionMat * vec4(pixelNDC, 1.0, 1.0);
    // Ray direction in world coordinate
    vec3 direction = (uniforms.invViewMat * directionCam).xyz;
    // Ray origin (camera position) in world coordinate
    vec3 origin = (uniforms.invViewMat * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
#else
    float focalLength = 1.0;
    float viewportHeight = 2.0;
    float viewportWidth = viewportHeight * float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    float u = (float(gl_LaunchIDEXT.x) + randomFloat(payload.randomState, 0.0, 1.0)) / float(gl_LaunchSizeEXT.x - 1);
    float v = 1.0 - (float(gl_LaunchIDEXT.y) + randomFloat(payload.randomState, 0.0, 1.0)) / float(gl_LaunchSizeEXT.y - 1);
    // Point on the image plane
    float x = viewportWidth * u - viewportWidth / 2.0;
    float y = viewportHeight * v - viewportHeight / 2.0;
  
    vec3 origin = vec3(0.0, 0.0, 0.0);
    vec3 direction = vec3(x, y, -1.0);
#endif

    int depth = 0;
    payload.color = vec3(1.0);

    do {
      float tMin = 0.001;
      float tMax = 10000.0;

      traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tMin, direction, tMax, 0);

      origin = payload.nextOrigin;
      direction = payload.nextDirection;

      depth++;
    } while (payload.traceNextRay && depth < MAX_DEPTH);

    meanColor = (i * meanColor + payload.color) / (i + 1); 
  }

  // Gamma correction
  vec3 correctedColor = sqrt(meanColor);

  imageStore(targetImage, ivec2(gl_LaunchIDEXT.xy), vec4(correctedColor, 1.0));
}